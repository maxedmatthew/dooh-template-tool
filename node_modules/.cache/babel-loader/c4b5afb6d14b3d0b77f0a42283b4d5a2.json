{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar effectsHelpers_1 = require(\"./effectsHelpers\");\n\nvar helpers_1 = require(\"./helpers\");\n\nvar psdReader_1 = require(\"./psdReader\");\n\nvar psdWriter_1 = require(\"./psdWriter\");\n\nvar descriptor_1 = require(\"./descriptor\");\n\nvar handlers = [];\nvar handlersMap = {};\n\nfunction addHandler(key, has, read, write) {\n  var handler = {\n    key: key,\n    has: has,\n    read: read,\n    write: write\n  };\n  handlers.push(handler);\n  handlersMap[handler.key] = handler;\n}\n\nfunction getHandler(key) {\n  return handlersMap[key];\n}\n\nexports.getHandler = getHandler;\n\nfunction getHandlers() {\n  return handlers;\n}\n\nexports.getHandlers = getHandlers;\n\nfunction revMap(map) {\n  var result = {};\n  Object.keys(map).forEach(function (key) {\n    return result[map[key]] = key;\n  });\n  return result;\n} // textGridding.None\n\n\nvar textGridding = {\n  none: 'None'\n};\nvar textGriddingRev = revMap(textGridding);\n\nfunction toTextGridding(value) {\n  return textGriddingRev[value.split('.')[1]] || 'none';\n}\n\nfunction fromTextGridding(value) {\n  return \"textGridding.\" + (textGridding[value] || 'None');\n} // Ornt.Hrzn | Ornt.Vrtc\n\n\nvar Ornt = {\n  horizontal: 'Hrzn',\n  vertical: 'Vrtc'\n};\nvar OrntRev = revMap(Ornt);\n\nfunction toOrientation(value) {\n  return OrntRev[value.split('.')[1]] || 'horizontal';\n}\n\nfunction fromOrientation(value) {\n  return \"textGridding.\" + (Ornt[value] || 'Hrzn');\n} // Annt.antiAliasSharp | Annt.Anno | Annt.AnCr | Annt.AnSt | Annt.AnSm\n\n\nvar Annt = {\n  none: 'Anno',\n  sharp: 'antiAliasSharp',\n  crisp: 'AnCr',\n  strong: 'AnSt',\n  smooth: 'AnSm'\n};\nvar AnntRev = revMap(Annt);\n\nfunction toAntialias(value) {\n  return AnntRev[value.split('.')[1]] || 'none';\n}\n\nfunction fromAntialias(value) {\n  return \"Annt.\" + (Annt[value] || 'Anno');\n} // warpStyle.warpNone | warpStyle.warpArc | warpStyle.warpArcLower | warpStyle.warpArcUpper | warpStyle.warpArch\n// warpStyle.warpBulge | warpStyle.warpShellLower | warpStyle.warpShellUpper | warpStyle.warpFlag\n// warpStyle.warpWave | warpStyle.warpFish | warpStyle.warpRise | warpStyle.warpFisheye |\n// warpStyle.warpInflate | warpStyle.warpSqueeze | warpStyle.warpTwist\n\n\nvar warpStyle = {\n  none: 'warpNone',\n  arc: 'warpArc',\n  arcLower: 'warpArcLower',\n  arcUpper: 'warpArcUpper',\n  arch: 'warpArch',\n  bulge: 'warpBulge',\n  shellLower: 'warpShellLower',\n  shellUpper: 'warpShellUpper',\n  flag: 'warpFlag',\n  wave: 'warpWave',\n  fish: 'warpFish',\n  rise: 'warpRise',\n  fisheye: 'warpFisheye',\n  inflate: 'warpInflate',\n  squeeze: 'warpSqueeze',\n  twist: 'warpTwist'\n};\nvar warpStyleRev = revMap(warpStyle);\n\nfunction toWarpStyle(value) {\n  return warpStyleRev[value.split('.')[1]] || 'none';\n}\n\nfunction fromWarpStyle(value) {\n  return \"warpStyle.\" + (warpStyle[value] || 'warpNone');\n}\n\naddHandler('TySh', function (target) {\n  return target.text !== undefined;\n}, function (reader, target) {\n  var version = psdReader_1.readInt16(reader);\n\n  if (version !== 1) {\n    throw new Error(\"Invalid TySh version: \" + version);\n  }\n\n  var transform = [psdReader_1.readFloat64(reader), psdReader_1.readFloat64(reader), psdReader_1.readFloat64(reader), psdReader_1.readFloat64(reader), psdReader_1.readFloat64(reader), psdReader_1.readFloat64(reader)];\n  var textVersion = psdReader_1.readInt16(reader);\n  var descriptorVersion = psdReader_1.readInt32(reader);\n\n  if (textVersion !== 50 || descriptorVersion !== 16) {\n    throw new Error(\"Invalid TySh text version: \" + textVersion + \"/\" + descriptorVersion);\n  }\n\n  var text = descriptor_1.readDescriptorStructure(reader); // console.log('EngineData:', JSON.stringify(parseEngineData(text.EngineData), null, 2), '\\n');\n\n  var warpVersion = psdReader_1.readInt16(reader);\n  var warpDescriptorVersion = psdReader_1.readInt32(reader);\n\n  if (warpVersion !== 1 || warpDescriptorVersion !== 16) {\n    throw new Error(\"Invalid TySh warp version: \" + warpVersion + \" \" + warpDescriptorVersion);\n  }\n\n  var warp = descriptor_1.readDescriptorStructure(reader);\n  var left = psdReader_1.readInt32(reader);\n  var top = psdReader_1.readInt32(reader);\n  var right = psdReader_1.readInt32(reader);\n  var bottom = psdReader_1.readInt32(reader);\n  target.text = {\n    transform: transform,\n    left: left,\n    top: top,\n    right: right,\n    bottom: bottom,\n    text: text['Txt '],\n    index: text.TextIndex || 0,\n    gridding: toTextGridding(text.textGridding),\n    antialias: toAntialias(text.AntA),\n    orientation: toOrientation(text.Ornt),\n    warp: {\n      style: toWarpStyle(warp.warpStyle),\n      value: warp.warpValue || 0,\n      perspective: warp.warpPerspective || 0,\n      perspectiveOther: warp.warpPerspectiveOther || 0,\n      rotate: toOrientation(warp.warpRotate)\n    }\n  };\n}, function (writer, target) {\n  var text = target.text;\n  var warp = text.warp || {};\n  var transform = text.transform || [1, 0, 0, 1, 0, 0];\n  var textDescriptor = {\n    'Txt ': text.text,\n    textGridding: fromTextGridding(text.gridding),\n    Ornt: fromOrientation(text.orientation),\n    AntA: fromAntialias(text.antialias),\n    TextIndex: text.index || 0\n  };\n  var warpDescriptor = {\n    warpStyle: fromWarpStyle(warp.style),\n    warpValue: warp.value || 0,\n    warpPerspective: warp.perspective || 0,\n    warpPerspectiveOther: warp.perspectiveOther || 0,\n    warpRotate: fromOrientation(warp.rotate)\n  };\n  psdWriter_1.writeInt16(writer, 1); // version\n\n  for (var i = 0; i < 6; i++) {\n    psdWriter_1.writeFloat64(writer, transform[i] || 0);\n  }\n\n  psdWriter_1.writeInt16(writer, 50); // text version\n\n  psdWriter_1.writeInt32(writer, 16); // text descriptor version\n\n  descriptor_1.writeDescriptorStructure(writer, '', 'TxLr', textDescriptor);\n  psdWriter_1.writeInt16(writer, 1); // warp version\n\n  psdWriter_1.writeInt32(writer, 16); // warp descriptor version\n\n  descriptor_1.writeDescriptorStructure(writer, '', 'warp', warpDescriptor);\n  psdWriter_1.writeInt32(writer, text.left || 0);\n  psdWriter_1.writeInt32(writer, text.top || 0);\n  psdWriter_1.writeInt32(writer, text.right || 0);\n  psdWriter_1.writeInt32(writer, text.bottom || 0);\n});\naddHandler('luni', function (target) {\n  return target.name !== undefined;\n}, function (reader, target, left) {\n  target.name = psdReader_1.readUnicodeString(reader);\n  psdReader_1.skipBytes(reader, left()); // TEMP: skipping\n}, function (writer, target) {\n  psdWriter_1.writeUnicodeString(writer, target.name);\n});\naddHandler('lnsr', function (target) {\n  return target.nameSource !== undefined;\n}, function (reader, target) {\n  return target.nameSource = psdReader_1.readSignature(reader);\n}, function (writer, target) {\n  return psdWriter_1.writeSignature(writer, target.nameSource);\n});\naddHandler('lyid', function (target) {\n  return target.id !== undefined;\n}, function (reader, target) {\n  return target.id = psdReader_1.readUint32(reader);\n}, function (writer, target) {\n  return psdWriter_1.writeUint32(writer, target.id);\n});\naddHandler('clbl', function (target) {\n  return target.blendClippendElements !== undefined;\n}, function (reader, target) {\n  target.blendClippendElements = !!psdReader_1.readUint8(reader);\n  psdReader_1.skipBytes(reader, 3);\n}, function (writer, target) {\n  psdWriter_1.writeUint8(writer, target.blendClippendElements ? 1 : 0);\n  psdWriter_1.writeZeros(writer, 3);\n});\naddHandler('infx', function (target) {\n  return target.blendInteriorElements !== undefined;\n}, function (reader, target) {\n  target.blendInteriorElements = !!psdReader_1.readUint8(reader);\n  psdReader_1.skipBytes(reader, 3);\n}, function (writer, target) {\n  psdWriter_1.writeUint8(writer, target.blendInteriorElements ? 1 : 0);\n  psdWriter_1.writeZeros(writer, 3);\n});\naddHandler('knko', function (target) {\n  return target.knockout !== undefined;\n}, function (reader, target) {\n  target.knockout = !!psdReader_1.readUint8(reader);\n  psdReader_1.skipBytes(reader, 3);\n}, function (writer, target) {\n  psdWriter_1.writeUint8(writer, target.knockout ? 1 : 0);\n  psdWriter_1.writeZeros(writer, 3);\n});\naddHandler('lspf', function (target) {\n  return target.protected !== undefined;\n}, function (reader, target) {\n  var flags = psdReader_1.readUint32(reader);\n  target.protected = {\n    transparency: (flags & 0x01) !== 0,\n    composite: (flags & 0x02) !== 0,\n    position: (flags & 0x04) !== 0\n  };\n}, function (writer, target) {\n  var flags = (target.protected.transparency ? 0x01 : 0) | (target.protected.composite ? 0x02 : 0) | (target.protected.position ? 0x04 : 0);\n  psdWriter_1.writeUint32(writer, flags);\n});\naddHandler('lclr', function (target) {\n  return target.sheetColors !== undefined;\n}, function (reader, target) {\n  target.sheetColors = {\n    color1: psdReader_1.readUint32(reader),\n    color2: psdReader_1.readUint32(reader)\n  };\n}, function (writer, target) {\n  psdWriter_1.writeUint32(writer, target.sheetColors.color1);\n  psdWriter_1.writeUint32(writer, target.sheetColors.color2);\n});\naddHandler('shmd', function (target) {\n  return target.metadata !== undefined;\n}, function (reader, target) {\n  var count = psdReader_1.readUint32(reader);\n  target.metadata = [];\n\n  for (var i = 0; i < count; i++) {\n    var signature = psdReader_1.readSignature(reader);\n    if (signature !== '8BIM') throw new Error(\"Invalid signature: '\" + signature + \"'\");\n    var key = psdReader_1.readSignature(reader);\n    var copy = !!psdReader_1.readUint8(reader);\n    psdReader_1.skipBytes(reader, 3);\n    var length_1 = psdReader_1.readUint32(reader);\n    var data = helpers_1.toArray(psdReader_1.readBytes(reader, length_1));\n    target.metadata.push({\n      key: key,\n      copy: copy,\n      data: data\n    });\n  }\n}, function (writer, target) {\n  psdWriter_1.writeUint32(writer, target.metadata.length);\n\n  for (var i = 0; i < target.metadata.length; i++) {\n    var item = target.metadata[i];\n    psdWriter_1.writeSignature(writer, '8BIM');\n    psdWriter_1.writeSignature(writer, item.key);\n    psdWriter_1.writeUint8(writer, item.copy ? 1 : 0);\n    psdWriter_1.writeZeros(writer, 3);\n    psdWriter_1.writeUint32(writer, item.data.length);\n    psdWriter_1.writeBytes(writer, new Uint8Array(item.data));\n  }\n});\naddHandler('fxrp', function (target) {\n  return target.referencePoint !== undefined;\n}, function (reader, target) {\n  target.referencePoint = {\n    x: psdReader_1.readFloat64(reader),\n    y: psdReader_1.readFloat64(reader)\n  };\n}, function (writer, target) {\n  psdWriter_1.writeFloat64(writer, target.referencePoint.x);\n  psdWriter_1.writeFloat64(writer, target.referencePoint.y);\n});\naddHandler('lsct', function (target) {\n  return target.sectionDivider !== undefined;\n}, function (reader, target, left) {\n  var item = {};\n  item.type = psdReader_1.readUint32(reader);\n\n  if (left()) {\n    var signature = psdReader_1.readSignature(reader);\n    if (signature !== '8BIM') throw new Error(\"Invalid signature: '\" + signature + \"'\");\n    item.key = psdReader_1.readSignature(reader);\n  }\n\n  if (left()) {\n    // 0 = normal\n    // 1 = scene group, affects the animation timeline.\n    item.subType = psdReader_1.readUint32(reader);\n  }\n\n  target.sectionDivider = item;\n}, function (writer, target) {\n  psdWriter_1.writeUint32(writer, target.sectionDivider.type);\n\n  if (target.sectionDivider.key) {\n    psdWriter_1.writeSignature(writer, '8BIM');\n    psdWriter_1.writeSignature(writer, target.sectionDivider.key);\n    if (target.sectionDivider.subtype !== undefined) psdWriter_1.writeUint32(writer, target.sectionDivider.subtype);\n  }\n});\naddHandler('lyvr', function (target) {\n  return target.version !== undefined;\n}, function (reader, target) {\n  target.version = psdReader_1.readUint32(reader);\n}, function (writer, target) {\n  psdWriter_1.writeUint32(writer, target.version);\n});\naddHandler('lrFX', function (target) {\n  return target.effects !== undefined;\n}, function (reader, target, left) {\n  target.effects = effectsHelpers_1.readEffects(reader);\n  psdReader_1.skipBytes(reader, left()); // TEMP: skipping\n}, function (writer, target) {\n  effectsHelpers_1.writeEffects(writer, target.effects);\n}); // addHandler(\n// \t'Txt2',\n// \ttarget => !!(target as any)['__Txt2'], // target.text !== undefined,\n// \t(reader, target, left) => {\n// \t\tconst textEngineData = readBytes(reader, left());\n// \t\t(target as any)['__Txt2'] = Array.from(textEngineData);\n// \t\tconsole.log('Txt2:textEngineData', parseEngineData(textEngineData));\n// \t},\n// \t(writer, target) => {\n// \t\twriteBytes(writer, new Uint8Array((target as any)['__Txt2'])); // new Uint8Array(target.textEngineData!));\n// \t},\n// );\n\naddHandler('FMsk', function (target) {\n  return target.filterMask !== undefined;\n}, function (reader, target) {\n  target.filterMask = {\n    colorSpace: helpers_1.readColor(reader),\n    opacity: psdReader_1.readUint16(reader)\n  };\n}, function (writer, target) {\n  psdWriter_1.writeBytes(writer, new Uint8Array(target.filterMask.colorSpace));\n  psdWriter_1.writeUint16(writer, target.filterMask.opacity);\n}); // TODO: implement\n\naddHandler('lfx2', function (target) {\n  return !target;\n}, // target.objectBasedEffectsLayerInfo !== undefined,\nfunction (reader, _target, left) {\n  psdReader_1.skipBytes(reader, left()); // const version = readUint32(reader);\n  // const descriptorVersion = readUint32(reader);\n  // const name = reader.readUnicodeString();\n  // const classId = readStringOrClassId(reader);\n  // const itemsCount = readUint32(reader);\n  //for (let i = 0; i < itemsCount; i++) {\n  //\tconsole.log('read item');\n  //\tconst key = readStringOrClassId(reader);\n  //\tconsole.log('key', [key]);\n  //}\n  //target.objectBasedEffectsLayerInfo = {\n  //\tversion,\n  //\tdescriptorVersion,\n  //\tdescriptor: {\n  //\t\tname,\n  //\t\tclassId,\n  //\t\t//...\n  //\t},\n  //};\n}, function (_writer, _target) {//...\n});","map":null,"metadata":{},"sourceType":"script"}