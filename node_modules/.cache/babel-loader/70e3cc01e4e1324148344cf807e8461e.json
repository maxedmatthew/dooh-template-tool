{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar psd_1 = require(\"./psd\");\n\nvar helpers_1 = require(\"./helpers\");\n\nvar additionalInfo_1 = require(\"./additionalInfo\");\n\nvar imageResources_1 = require(\"./imageResources\");\n\nvar supportedColorModes = [0\n/* Bitmap */\n, 1\n/* Grayscale */\n, 3\n/* RGB */\n];\n\nfunction setupGrayscale(data) {\n  var size = data.width * data.height * 4;\n\n  for (var i = 0; i < size; i += 4) {\n    data.data[i + 1] = data.data[i];\n    data.data[i + 2] = data.data[i];\n  }\n}\n\nfunction createReader(buffer, offset, length) {\n  var view = new DataView(buffer, offset, length);\n  return {\n    view: view,\n    offset: 0\n  };\n}\n\nexports.createReader = createReader;\n\nfunction readUint8(reader) {\n  reader.offset += 1;\n  return reader.view.getUint8(reader.offset - 1);\n}\n\nexports.readUint8 = readUint8;\n\nfunction peekUint8(reader) {\n  return reader.view.getUint8(reader.offset);\n}\n\nexports.peekUint8 = peekUint8;\n\nfunction readInt16(reader) {\n  reader.offset += 2;\n  return reader.view.getInt16(reader.offset - 2, false);\n}\n\nexports.readInt16 = readInt16;\n\nfunction readUint16(reader) {\n  reader.offset += 2;\n  return reader.view.getUint16(reader.offset - 2, false);\n}\n\nexports.readUint16 = readUint16;\n\nfunction readInt32(reader) {\n  reader.offset += 4;\n  return reader.view.getInt32(reader.offset - 4, false);\n}\n\nexports.readInt32 = readInt32;\n\nfunction readInt32LE(reader) {\n  reader.offset += 4;\n  return reader.view.getInt32(reader.offset - 4, true);\n}\n\nexports.readInt32LE = readInt32LE;\n\nfunction readUint32(reader) {\n  reader.offset += 4;\n  return reader.view.getUint32(reader.offset - 4, false);\n}\n\nexports.readUint32 = readUint32;\n\nfunction readFloat32(reader) {\n  reader.offset += 4;\n  return reader.view.getFloat32(reader.offset - 4, false);\n}\n\nexports.readFloat32 = readFloat32;\n\nfunction readFloat64(reader) {\n  reader.offset += 8;\n  return reader.view.getFloat64(reader.offset - 8, false);\n}\n\nexports.readFloat64 = readFloat64;\n\nfunction readBytes(reader, length) {\n  reader.offset += length;\n  return new Uint8Array(reader.view.buffer, reader.view.byteOffset + reader.offset - length, length);\n}\n\nexports.readBytes = readBytes;\n\nfunction readSignature(reader) {\n  return readShortString(reader, 4);\n}\n\nexports.readSignature = readSignature;\n\nfunction readPascalString(reader, padTo) {\n  if (padTo === void 0) {\n    padTo = 2;\n  }\n\n  var length = readUint8(reader);\n  var text = readShortString(reader, length);\n\n  while (++length % padTo) {\n    skipBytes(reader, 1);\n  }\n\n  return text;\n}\n\nexports.readPascalString = readPascalString;\n\nfunction readUnicodeString(reader) {\n  var length = readUint32(reader);\n  return readUnicodeStringWithLength(reader, length);\n}\n\nexports.readUnicodeString = readUnicodeString;\n\nfunction readUnicodeStringWithLength(reader, length) {\n  var text = '';\n\n  while (length--) {\n    var value = readUint16(reader);\n\n    if (value || length > 0) {\n      // remove trailing \\0\n      text += String.fromCharCode(value);\n    }\n  }\n\n  return text;\n}\n\nexports.readUnicodeStringWithLength = readUnicodeStringWithLength;\n\nfunction readAsciiString(reader, length) {\n  var text = '';\n\n  while (length--) {\n    text += String.fromCharCode(readUint8(reader));\n  }\n\n  return text;\n}\n\nexports.readAsciiString = readAsciiString; // export function readUtf8String(reader: PsdReader, length: number) {\n// \tconst buffer = readBytes(reader, length);\n// \treturn decodeString(buffer);\n// }\n\nfunction skipBytes(reader, count) {\n  reader.offset += count;\n}\n\nexports.skipBytes = skipBytes;\n\nfunction checkSignature(reader) {\n  var expected = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    expected[_i - 1] = arguments[_i];\n  }\n\n  var offset = reader.offset;\n  var signature = readSignature(reader);\n  /* istanbul ignore if */\n\n  if (expected.indexOf(signature) === -1) {\n    throw new Error(\"Invalid signature: '\" + signature + \"' at 0x\" + offset.toString(16));\n  }\n}\n\nexports.checkSignature = checkSignature;\n\nfunction readShortString(reader, length) {\n  var buffer = readBytes(reader, length);\n  return String.fromCharCode.apply(String, buffer);\n}\n\nfunction readPsd(reader, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var psd = readHeader(reader);\n  readColorModeData(reader, psd, options);\n  readImageResources(reader, psd, options);\n  var globalAlpha = readLayerAndMaskInfo(reader, psd, options);\n  var hasChildren = psd.children && psd.children.length;\n  var skipComposite = options.skipCompositeImageData && (options.skipLayerImageData || hasChildren);\n\n  if (!skipComposite) {\n    readImageData(reader, psd, globalAlpha);\n  }\n\n  return psd;\n}\n\nexports.readPsd = readPsd;\n\nfunction readHeader(reader) {\n  checkSignature(reader, '8BPS');\n  var version = readUint16(reader);\n  /* istanbul ignore if */\n\n  if (version !== 1) throw new Error(\"Invalid PSD file version: \" + version);\n  skipBytes(reader, 6);\n  var channels = readUint16(reader);\n  var height = readUint32(reader);\n  var width = readUint32(reader);\n  var bitsPerChannel = readUint16(reader);\n  var colorMode = readUint16(reader);\n  /* istanbul ignore if */\n\n  if (supportedColorModes.indexOf(colorMode) === -1) throw new Error(\"Color mode not supported: \" + colorMode);\n  return {\n    width: width,\n    height: height,\n    channels: channels,\n    bitsPerChannel: bitsPerChannel,\n    colorMode: colorMode\n  };\n}\n\nfunction readColorModeData(reader, _psd, options) {\n  readSection(reader, 1, function (left) {\n    if (options.throwForMissingFeatures) {\n      throw new Error('Not Implemented: color mode data');\n    } else {\n      skipBytes(reader, left());\n    }\n  });\n}\n\nfunction readImageResources(reader, psd, options) {\n  readSection(reader, 1, function (left) {\n    while (left()) {\n      readImageResource(reader, psd, options);\n    }\n  });\n}\n\nfunction readImageResource(reader, psd, options) {\n  checkSignature(reader, '8BIM');\n  var id = readUint16(reader);\n  var name = readPascalString(reader);\n  readSection(reader, 2, function (left) {\n    var handler = imageResources_1.getHandler(id, name);\n    var skip = id === 1036 && !!options.skipThumbnail;\n\n    if (!psd.imageResources) {\n      psd.imageResources = {};\n    }\n\n    if (handler && !skip) {\n      handler.read(reader, psd.imageResources, left, options);\n    } else {\n      // console.log(`Image resource: ${id} ${name} ${getImageResourceName(id).substr(0, 90) }`);\n      skipBytes(reader, left());\n    }\n  });\n}\n\nfunction readLayerAndMaskInfo(reader, psd, options) {\n  var globalAlpha = false;\n  readSection(reader, 1, function (left) {\n    globalAlpha = readLayerInfo(reader, psd, options); // SAI does not include this section\n\n    if (left() > 0) {\n      readGlobalLayerMaskInfo(reader);\n    } else {\n      // revert back to end of section if exceeded section limits\n      skipBytes(reader, left());\n    }\n\n    while (left() > 0) {\n      // sometimes there are empty bytes here\n      while (left() && peekUint8(reader) === 0) {\n        skipBytes(reader, 1);\n      }\n\n      if (left() >= 12) {\n        readAdditionalLayerInfo(reader, psd, !!options.logMissingFeatures);\n      } else {\n        skipBytes(reader, left());\n      }\n    }\n  });\n  return globalAlpha;\n}\n\nfunction readLayerInfo(reader, psd, options) {\n  var globalAlpha = false;\n  readSection(reader, 2, function (left) {\n    var layerCount = readInt16(reader);\n\n    if (layerCount < 0) {\n      globalAlpha = true;\n      layerCount = -layerCount;\n    }\n\n    var layers = [];\n    var layerChannels = [];\n\n    for (var i = 0; i < layerCount; i++) {\n      var _a = readLayerRecord(reader, options),\n          layer = _a.layer,\n          channels = _a.channels;\n\n      layers.push(layer);\n      layerChannels.push(channels);\n    }\n\n    if (!options.skipLayerImageData) {\n      for (var i = 0; i < layerCount; i++) {\n        readLayerChannelImageData(reader, psd, layers[i], layerChannels[i], options);\n      }\n    }\n\n    skipBytes(reader, left());\n\n    if (!psd.children) {\n      psd.children = [];\n    }\n\n    var stack = [psd];\n\n    for (var i = layers.length - 1; i >= 0; i--) {\n      var l = layers[i];\n      var type = l.sectionDivider ? l.sectionDivider.type : 0\n      /* Other */\n      ;\n\n      if (type === 1\n      /* OpenFolder */\n      || type === 2\n      /* ClosedFolder */\n      ) {\n          l.opened = type === 1\n          /* OpenFolder */\n          ;\n          l.children = [];\n          stack[stack.length - 1].children.unshift(l);\n          stack.push(l);\n        } else if (type === 3\n      /* BoundingSectionDivider */\n      ) {\n          stack.pop();\n        } else {\n        stack[stack.length - 1].children.unshift(l);\n      }\n    }\n  });\n  return globalAlpha;\n}\n\nfunction readLayerRecord(reader, options) {\n  var layer = {};\n  layer.top = readInt32(reader);\n  layer.left = readInt32(reader);\n  layer.bottom = readInt32(reader);\n  layer.right = readInt32(reader);\n  var channelCount = readUint16(reader);\n  var channels = [];\n\n  for (var i = 0; i < channelCount; i++) {\n    var channelID = readInt16(reader);\n    var channelLength = readInt32(reader);\n    channels.push({\n      id: channelID,\n      length: channelLength\n    });\n  }\n\n  checkSignature(reader, '8BIM');\n  var blendMode = readSignature(reader);\n  /* istanbul ignore if */\n\n  if (!psd_1.toBlendMode[blendMode]) throw new Error(\"Invalid blend mode: '\" + blendMode + \"'\");\n  layer.blendMode = psd_1.toBlendMode[blendMode];\n  layer.opacity = readUint8(reader);\n  layer.clipping = readUint8(reader) === 1;\n  var flags = readUint8(reader);\n  layer.transparencyProtected = (flags & 0x01) !== 0;\n  layer.hidden = (flags & 0x02) !== 0;\n  skipBytes(reader, 1);\n  readSection(reader, 1, function (left) {\n    var mask = readLayerMaskData(reader, options);\n\n    if (mask) {\n      layer.mask = mask;\n    }\n    /*const blendingRanges =*/\n\n\n    readLayerBlendingRanges(reader);\n    layer.name = readPascalString(reader, 4);\n\n    while (left()) {\n      readAdditionalLayerInfo(reader, layer, !!options.logMissingFeatures);\n    }\n  });\n  return {\n    layer: layer,\n    channels: channels\n  };\n}\n\nfunction readLayerMaskData(reader, _options) {\n  return readSection(reader, 1, function (bytesLeft) {\n    if (bytesLeft()) {\n      var mask = {};\n      mask.top = readInt32(reader);\n      mask.left = readInt32(reader);\n      mask.bottom = readInt32(reader);\n      mask.right = readInt32(reader);\n      mask.defaultColor = readUint8(reader);\n      var flags = readUint8(reader);\n      mask.disabled = (flags & 2\n      /* LayerMaskDisabled */\n      ) !== 0;\n      mask.positionRelativeToLayer = (flags & 1\n      /* PositionRelativeToLayer */\n      ) !== 0; // TODO: handle LayerMaskFlags.LayerMaskFromRenderingOtherData\n\n      if (flags & 16\n      /* MaskHasParametersAppliedToIt */\n      ) {\n          var parameters = readUint8(reader);\n          if (parameters & 1\n          /* UserMaskDensity */\n          ) mask.userMaskDensity = readUint8(reader);\n          if (parameters & 2\n          /* UserMaskFeather */\n          ) mask.userMaskFeather = readFloat64(reader);\n          if (parameters & 1\n          /* UserMaskDensity */\n          ) mask.vectorMaskDensity = readUint8(reader);\n          if (parameters & 2\n          /* UserMaskFeather */\n          ) mask.vectorMaskFeather = readFloat64(reader);\n        }\n\n      if (bytesLeft() > 2) {\n        // TODO: handle these values\n\n        /*const realFlags =*/\n        readUint8(reader);\n        /*const realUserMaskBackground =*/\n\n        readUint8(reader);\n        /*const top2 =*/\n\n        readInt32(reader);\n        /*const left2 =*/\n\n        readInt32(reader);\n        /*const bottom2 =*/\n\n        readInt32(reader);\n        /*const right2 =*/\n\n        readInt32(reader);\n      }\n\n      skipBytes(reader, bytesLeft());\n      return mask;\n    } else {\n      return undefined;\n    }\n  });\n}\n\nfunction readLayerBlendingRanges(reader) {\n  return readSection(reader, 1, function (left) {\n    var compositeGrayBlendSource = readUint32(reader);\n    var compositeGraphBlendDestinationRange = readUint32(reader);\n    var ranges = [];\n\n    while (left()) {\n      var sourceRange = readUint32(reader);\n      var destRange = readUint32(reader);\n      ranges.push({\n        sourceRange: sourceRange,\n        destRange: destRange\n      });\n    }\n\n    return {\n      compositeGrayBlendSource: compositeGrayBlendSource,\n      compositeGraphBlendDestinationRange: compositeGraphBlendDestinationRange,\n      ranges: ranges\n    };\n  });\n}\n\nfunction readLayerChannelImageData(reader, psd, layer, channels, options) {\n  var layerWidth = (layer.right || 0) - (layer.left || 0);\n  var layerHeight = (layer.bottom || 0) - (layer.top || 0);\n  var canvas;\n  var context;\n  var data;\n\n  if (layerWidth && layerHeight) {\n    canvas = helpers_1.createCanvas(layerWidth, layerHeight);\n    context = canvas.getContext('2d');\n    data = context.createImageData(layerWidth, layerHeight);\n    helpers_1.resetCanvas(data);\n  }\n\n  for (var _i = 0, channels_1 = channels; _i < channels_1.length; _i++) {\n    var channel = channels_1[_i];\n    var compression = readUint16(reader);\n\n    if (channel.id === -2\n    /* UserMask */\n    ) {\n        var mask = layer.mask;\n\n        if (!mask) {\n          throw new Error(\"Missing layer mask data\");\n        }\n\n        var maskWidth = (mask.right || 0) - (mask.left || 0);\n        var maskHeight = (mask.bottom || 0) - (mask.top || 0);\n\n        if (maskWidth && maskHeight) {\n          mask.canvas = helpers_1.createCanvas(maskWidth, maskHeight);\n          var context_1 = mask.canvas.getContext('2d');\n          var data_1 = context_1.createImageData(maskWidth, maskHeight);\n          helpers_1.resetCanvas(data_1);\n          readData(reader, data_1, compression, maskWidth, maskHeight, 0);\n          setupGrayscale(data_1);\n          context_1.putImageData(data_1, 0, 0);\n        }\n      } else {\n      var offset = helpers_1.offsetForChannel(channel.id);\n      var targetData = data;\n      /* istanbul ignore if */\n\n      if (offset < 0) {\n        targetData = undefined;\n\n        if (options.throwForMissingFeatures) {\n          throw new Error(\"Channel not supported: \" + channel.id);\n        }\n      }\n\n      readData(reader, targetData, compression, layerWidth, layerHeight, offset);\n\n      if (targetData && psd.colorMode === 1\n      /* Grayscale */\n      ) {\n          setupGrayscale(targetData);\n        }\n    }\n  }\n\n  if (context && data) {\n    context.putImageData(data, 0, 0);\n    layer.canvas = canvas;\n  }\n}\n\nfunction readData(reader, data, compression, width, height, offset) {\n  if (compression === 0\n  /* RawData */\n  ) {\n      helpers_1.readDataRaw(reader, data, offset, width, height);\n    } else if (compression === 1\n  /* RleCompressed */\n  ) {\n      helpers_1.readDataRLE(reader, data, width, height, 4, [offset]);\n    } else {\n    throw new Error(\"Compression type not supported: \" + compression);\n  }\n}\n\nfunction readGlobalLayerMaskInfo(reader) {\n  return readSection(reader, 1, function (left) {\n    if (left()) {\n      var overlayColorSpace = readUint16(reader);\n      var colorSpace1 = readUint16(reader);\n      var colorSpace2 = readUint16(reader);\n      var colorSpace3 = readUint16(reader);\n      var colorSpace4 = readUint16(reader);\n      var opacity = readUint16(reader);\n      var kind = readUint8(reader);\n      skipBytes(reader, left());\n      return {\n        overlayColorSpace: overlayColorSpace,\n        colorSpace1: colorSpace1,\n        colorSpace2: colorSpace2,\n        colorSpace3: colorSpace3,\n        colorSpace4: colorSpace4,\n        opacity: opacity,\n        kind: kind\n      };\n    }\n  });\n}\n\nfunction readAdditionalLayerInfo(reader, target, logMissing) {\n  checkSignature(reader, '8BIM', '8B64');\n  var key = readSignature(reader);\n  readSection(reader, 2, function (left) {\n    var handler = additionalInfo_1.getHandler(key);\n\n    if (handler) {\n      handler.read(reader, target, left);\n    } else {\n      logMissing && console.log(\"Unhandled additional info: \" + key);\n      skipBytes(reader, left());\n    }\n\n    if (left()) {\n      logMissing && console.log(\"Unread \" + left() + \" bytes left for tag: \" + key);\n      skipBytes(reader, left());\n    }\n  });\n}\n\nfunction readImageData(reader, psd, globalAlpha) {\n  var compression = readUint16(reader);\n  if (supportedColorModes.indexOf(psd.colorMode) === -1) throw new Error(\"Color mode not supported: \" + psd.colorMode);\n  if (compression !== 0\n  /* RawData */\n  && compression !== 1\n  /* RleCompressed */\n  ) throw new Error(\"Compression type not supported: \" + compression);\n  var canvas = helpers_1.createCanvas(psd.width, psd.height);\n  var context = canvas.getContext('2d');\n  var data = context.createImageData(psd.width, psd.height);\n  helpers_1.resetCanvas(data);\n\n  if (psd.colorMode === 0\n  /* Bitmap */\n  ) {\n      var bytes = void 0;\n\n      if (compression === 0\n      /* RawData */\n      ) {\n          bytes = readBytes(reader, Math.ceil(psd.width / 8) * psd.height);\n        } else if (compression === 1\n      /* RleCompressed */\n      ) {\n          bytes = new Uint8Array(psd.width * psd.height);\n          helpers_1.readDataRLE(reader, {\n            data: bytes,\n            width: psd.width,\n            height: psd.height\n          }, psd.width, psd.height, 1, [0]);\n        } else {\n        throw new Error(\"Unsupported compression: \" + compression);\n      }\n\n      helpers_1.decodeBitmap(bytes, data.data, psd.width, psd.height);\n    } else {\n    // Grayscale | RGB\n    var channels = psd.colorMode === 3\n    /* RGB */\n    ? [0, 1, 2] : [0];\n\n    if (psd.channels && psd.channels > 3) {\n      for (var i = 3; i < psd.channels; i++) {\n        channels.push(i);\n      }\n    } else if (globalAlpha) {\n      channels.push(3);\n    }\n\n    if (compression === 0\n    /* RawData */\n    ) {\n        for (var i = 0; i < channels.length; i++) {\n          helpers_1.readDataRaw(reader, data, channels[i], psd.width, psd.height);\n        }\n      } else if (compression === 1\n    /* RleCompressed */\n    ) {\n        helpers_1.readDataRLE(reader, data, psd.width, psd.height, 4, channels);\n      }\n\n    if (psd.colorMode === 1\n    /* Grayscale */\n    ) {\n        setupGrayscale(data);\n      }\n  }\n\n  context.putImageData(data, 0, 0);\n  psd.canvas = canvas;\n}\n\nfunction readSection(reader, round, func) {\n  var length = readInt32(reader);\n\n  if (length <= 0) {\n    return undefined;\n  }\n\n  var end = reader.offset + length;\n  var result = func(function () {\n    return end - reader.offset;\n  });\n  /* istanbul ignore if */\n\n  if (reader.offset > end) {\n    throw new Error('Exceeded section limits');\n  }\n  /* istanbul ignore if */\n\n\n  if (reader.offset !== end) {\n    throw new Error(\"Unread section data: \" + (end - reader.offset) + \" bytes at 0x\" + reader.offset.toString(16));\n  }\n\n  while (end % round) {\n    end++;\n  }\n\n  reader.offset = end;\n  return result;\n}","map":null,"metadata":{},"sourceType":"script"}