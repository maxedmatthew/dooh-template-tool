{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar psdReader_1 = require(\"./psdReader\");\n\nvar base64_js_1 = require(\"base64-js\");\n\nfunction offsetForChannel(channelId) {\n  switch (channelId) {\n    case 0\n    /* Red */\n    :\n      return 0;\n\n    case 1\n    /* Green */\n    :\n      return 1;\n\n    case 2\n    /* Blue */\n    :\n      return 2;\n\n    case -1\n    /* Transparency */\n    :\n      return 3;\n\n    default:\n      return channelId + 1;\n  }\n}\n\nexports.offsetForChannel = offsetForChannel;\n\nfunction toArray(value) {\n  var result = new Array(value.length);\n\n  for (var i = 0; i < value.length; i++) {\n    result[i] = value[i];\n  }\n\n  return result;\n}\n\nexports.toArray = toArray;\n\nfunction readColor(reader) {\n  return toArray(psdReader_1.readBytes(reader, 10));\n}\n\nexports.readColor = readColor;\n\nfunction hasAlpha(data) {\n  var size = data.width * data.height * 4;\n\n  for (var i = 3; i < size; i += 4) {\n    if (data.data[i] !== 255) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexports.hasAlpha = hasAlpha;\n\nfunction isRowEmpty(_a, y, left, right) {\n  var data = _a.data,\n      width = _a.width;\n  var start = (y * width + left) * 4 + 3 | 0;\n  var end = start + (right - left) * 4 | 0;\n\n  for (var i = start; i < end; i = i + 4 | 0) {\n    if (data[i] !== 0) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isColEmpty(_a, x, top, bottom) {\n  var data = _a.data,\n      width = _a.width;\n  var stride = width * 4 | 0;\n  var start = top * stride + x * 4 + 3 | 0;\n\n  for (var y = top, i = start; y < bottom; y++, i = i + stride | 0) {\n    if (data[i] !== 0) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction trimData(data) {\n  var top = 0;\n  var left = 0;\n  var right = data.width;\n  var bottom = data.height;\n\n  while (top < bottom && isRowEmpty(data, top, left, right)) {\n    top++;\n  }\n\n  while (bottom > top && isRowEmpty(data, bottom - 1, left, right)) {\n    bottom--;\n  }\n\n  while (left < right && isColEmpty(data, left, top, bottom)) {\n    left++;\n  }\n\n  while (right > left && isColEmpty(data, right - 1, top, bottom)) {\n    right--;\n  }\n\n  return {\n    top: top,\n    left: left,\n    right: right,\n    bottom: bottom\n  };\n}\n\nfunction getLayerDimentions(_a) {\n  var canvas = _a.canvas;\n\n  if (canvas && canvas.width && canvas.height) {\n    return {\n      width: canvas.width,\n      height: canvas.height\n    };\n  } else {\n    return {\n      width: 0,\n      height: 0\n    };\n  }\n}\n\nexports.getLayerDimentions = getLayerDimentions;\n\nfunction getChannels(tempBuffer, layer, background, options) {\n  var layerData = getLayerChannels(tempBuffer, layer, background, options);\n  var mask = layer.mask;\n\n  if (mask && mask.canvas) {\n    var _a = mask.top,\n        top_1 = _a === void 0 ? 0 : _a,\n        _b = mask.left,\n        left = _b === void 0 ? 0 : _b,\n        _c = mask.right,\n        right = _c === void 0 ? 0 : _c,\n        _d = mask.bottom,\n        bottom = _d === void 0 ? 0 : _d;\n\n    var _e = getLayerDimentions(mask),\n        width = _e.width,\n        height = _e.height;\n\n    if (width && height) {\n      right = left + width;\n      bottom = top_1 + height;\n      var context_1 = mask.canvas.getContext('2d');\n      var data = context_1.getImageData(0, 0, width, height);\n      var buffer = writeDataRLE(tempBuffer, data, width, height, [0]);\n      layerData.mask = {\n        top: top_1,\n        left: left,\n        right: right,\n        bottom: bottom\n      };\n      layerData.channels.push({\n        channelId: -2\n        /* UserMask */\n        ,\n        compression: 1\n        /* RleCompressed */\n        ,\n        buffer: buffer,\n        length: 2 + buffer.length\n      });\n    }\n  }\n\n  return layerData;\n}\n\nexports.getChannels = getChannels;\n\nfunction getLayerChannels(tempBuffer, layer, background, options) {\n  var canvas = layer.canvas;\n  var _a = layer.top,\n      top = _a === void 0 ? 0 : _a,\n      _b = layer.left,\n      left = _b === void 0 ? 0 : _b,\n      _c = layer.right,\n      right = _c === void 0 ? 0 : _c,\n      _d = layer.bottom,\n      bottom = _d === void 0 ? 0 : _d;\n  var channels = [{\n    channelId: -1\n    /* Transparency */\n    ,\n    compression: 0\n    /* RawData */\n    ,\n    buffer: undefined,\n    length: 2\n  }];\n\n  var _e = getLayerDimentions(layer),\n      width = _e.width,\n      height = _e.height;\n\n  if (!canvas || !width || !height) {\n    right = left;\n    bottom = top;\n    return {\n      layer: layer,\n      top: top,\n      left: left,\n      right: right,\n      bottom: bottom,\n      channels: channels\n    };\n  }\n\n  right = left + width;\n  bottom = top + height;\n  var context = canvas.getContext('2d');\n  var data = context.getImageData(0, 0, width, height);\n\n  if (options.trimImageData) {\n    var trimmed = trimData(data);\n\n    if (trimmed.left !== 0 || trimmed.top !== 0 || trimmed.right !== data.width || trimmed.bottom !== data.height) {\n      left += trimmed.left;\n      top += trimmed.top;\n      right -= data.width - trimmed.right;\n      bottom -= data.height - trimmed.bottom;\n      width = right - left;\n      height = bottom - top;\n\n      if (!width || !height) {\n        return {\n          layer: layer,\n          top: top,\n          left: left,\n          right: right,\n          bottom: bottom,\n          channels: channels\n        };\n      }\n\n      data = context.getImageData(trimmed.left, trimmed.top, width, height);\n    }\n  }\n\n  var channelIds = [0\n  /* Red */\n  , 1\n  /* Green */\n  , 2\n  /* Blue */\n  ];\n\n  if (!background || hasAlpha(data) || layer.mask) {\n    channelIds.unshift(-1\n    /* Transparency */\n    );\n  }\n\n  channels = channelIds.map(function (channel) {\n    var offset = offsetForChannel(channel);\n    var buffer = writeDataRLE(tempBuffer, data, width, height, [offset]);\n    return {\n      channelId: channel,\n      compression: 1\n      /* RleCompressed */\n      ,\n      buffer: buffer,\n      length: 2 + buffer.length\n    };\n  });\n  return {\n    layer: layer,\n    top: top,\n    left: left,\n    right: right,\n    bottom: bottom,\n    channels: channels\n  };\n}\n\nexports.getLayerChannels = getLayerChannels;\n\nfunction resetCanvas(_a) {\n  var width = _a.width,\n      height = _a.height,\n      data = _a.data;\n  var size = width * height | 0;\n  var buffer = new Uint32Array(data.buffer);\n\n  for (var p = 0; p < size; p = p + 1 | 0) {\n    buffer[p] = 0xff000000;\n  }\n}\n\nexports.resetCanvas = resetCanvas;\n\nfunction decodeBitmap(input, output, width, height) {\n  for (var y = 0, p = 0, o = 0; y < height; y++) {\n    for (var x = 0; x < width;) {\n      var b = input[o++];\n\n      for (var i = 0; i < 8 && x < width; i++, x++) {\n        var v = b & 0x80 ? 0 : 255;\n        b = b << 1;\n        output[p++] = v;\n        output[p++] = v;\n        output[p++] = v;\n        output[p++] = 255;\n      }\n    }\n  }\n}\n\nexports.decodeBitmap = decodeBitmap;\n\nfunction writeDataRaw(data, offset, width, height) {\n  if (!width || !height) return undefined;\n  var array = new Uint8Array(width * height);\n\n  for (var i = 0; i < array.length; i++) {\n    array[i] = data.data[i * 4 + offset];\n  }\n\n  return array;\n}\n\nexports.writeDataRaw = writeDataRaw;\n\nfunction readDataRaw(reader, pixelData, offset, width, height) {\n  var size = width * height;\n  var buffer = psdReader_1.readBytes(reader, size);\n\n  if (pixelData && offset < 4) {\n    var data = pixelData.data;\n\n    for (var i = 0, p = offset | 0; i < size; i++, p = p + 4 | 0) {\n      data[p] = buffer[i];\n    }\n  }\n}\n\nexports.readDataRaw = readDataRaw;\n\nfunction writeDataRLE(buffer, _a, width, height, offsets) {\n  var data = _a.data;\n  if (!width || !height) return undefined;\n  var stride = 4 * width | 0;\n  var ol = 0;\n  var o = offsets.length * 2 * height | 0;\n\n  for (var _i = 0, offsets_1 = offsets; _i < offsets_1.length; _i++) {\n    var offset = offsets_1[_i];\n\n    for (var y = 0, p = offset | 0; y < height; y++) {\n      var strideStart = y * stride | 0;\n      var strideEnd = strideStart + stride | 0;\n      var lastIndex = strideEnd + offset - 4 | 0;\n      var lastIndex2 = lastIndex - 4 | 0;\n      var startOffset = o;\n\n      for (p = strideStart + offset | 0; p < strideEnd; p = p + 4 | 0) {\n        if (p < lastIndex2) {\n          var value1 = data[p];\n          p = p + 4 | 0;\n          var value2 = data[p];\n          p = p + 4 | 0;\n          var value3 = data[p];\n\n          if (value1 === value2 && value1 === value3) {\n            var count = 3;\n\n            while (count < 128 && p < lastIndex && data[p + 4 | 0] === value1) {\n              count = count + 1 | 0;\n              p = p + 4 | 0;\n            }\n\n            buffer[o++] = 1 - count;\n            buffer[o++] = value1;\n          } else {\n            var countIndex = o;\n            var writeLast = true;\n            var count = 1;\n            buffer[o++] = 0;\n            buffer[o++] = value1;\n\n            while (p < lastIndex && count < 128) {\n              p = p + 4 | 0;\n              value1 = value2;\n              value2 = value3;\n              value3 = data[p];\n\n              if (value1 === value2 && value1 === value3) {\n                p = p - 12 | 0;\n                writeLast = false;\n                break;\n              } else {\n                count++;\n                buffer[o++] = value1;\n              }\n            }\n\n            if (writeLast) {\n              if (count < 127) {\n                buffer[o++] = value2;\n                buffer[o++] = value3;\n                count += 2;\n              } else if (count < 128) {\n                buffer[o++] = value2;\n                count++;\n                p = p - 4 | 0;\n              } else {\n                p = p - 8 | 0;\n              }\n            }\n\n            buffer[countIndex] = count - 1;\n          }\n        } else if (p === lastIndex) {\n          buffer[o++] = 0;\n          buffer[o++] = data[p];\n        } else {\n          // p === lastIndex2\n          buffer[o++] = 1;\n          buffer[o++] = data[p];\n          p = p + 4 | 0;\n          buffer[o++] = data[p];\n        }\n      }\n\n      var length_1 = o - startOffset;\n      buffer[ol++] = length_1 >> 8 & 0xff;\n      buffer[ol++] = length_1 & 0xff;\n    }\n  }\n\n  return buffer.slice(0, o);\n}\n\nexports.writeDataRLE = writeDataRLE;\n\nfunction readDataRLE(reader, pixelData, _width, height, step, offsets) {\n  var lengths = new Uint16Array(offsets.length * height);\n  var data = pixelData && pixelData.data;\n\n  for (var o = 0, li = 0; o < offsets.length; o++) {\n    for (var y = 0; y < height; y++, li++) {\n      lengths[li] = psdReader_1.readUint16(reader);\n    }\n  }\n\n  for (var c = 0, li = 0; c < offsets.length; c++) {\n    var offset = offsets[c] | 0;\n    var extra = c > 3 || offset > 3;\n\n    if (!data || extra) {\n      for (var y = 0; y < height; y++, li++) {\n        psdReader_1.skipBytes(reader, lengths[li]);\n      }\n    } else {\n      for (var y = 0, p = offset | 0; y < height; y++, li++) {\n        var length_2 = lengths[li];\n        var buffer = psdReader_1.readBytes(reader, length_2);\n\n        for (var i = 0; i < length_2; i++) {\n          var header = buffer[i];\n\n          if (header >= 128) {\n            var value = buffer[++i];\n            header = 256 - header | 0;\n\n            for (var j = 0; j <= header; j = j + 1 | 0) {\n              data[p] = value;\n              p = p + step | 0;\n            }\n          } else {\n            // header < 128\n            for (var j = 0; j <= header; j = j + 1 | 0) {\n              data[p] = buffer[++i];\n              p = p + step | 0;\n            }\n          }\n          /* istanbul ignore if */\n\n\n          if (i >= length_2) {\n            throw new Error(\"Invalid RLE data: exceeded buffer size \" + i + \"/\" + length_2);\n          }\n        }\n      }\n    }\n  }\n}\n\nexports.readDataRLE = readDataRLE;\n/* istanbul ignore next */\n\nexports.createCanvas = function () {\n  throw new Error('Canvas not initialized, use initializeCanvas method to set up createCanvas method');\n};\n/* istanbul ignore next */\n\n\nexports.createCanvasFromData = function () {\n  throw new Error('Canvas not initialized, use initializeCanvas method to set up createCanvasFromData method');\n};\n/* istanbul ignore if */\n\n\nif (typeof document !== 'undefined') {\n  exports.createCanvas = function (width, height) {\n    var canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  };\n\n  exports.createCanvasFromData = function (data) {\n    var image = new Image();\n    image.src = 'data:image/jpeg;base64,' + base64_js_1.fromByteArray(data);\n    var canvas = document.createElement('canvas');\n    canvas.width = image.width;\n    canvas.height = image.height;\n    canvas.getContext('2d').drawImage(image, 0, 0);\n    return canvas;\n  };\n}\n\nfunction initializeCanvas(createCanvasMethod, createCanvasFromDataMethod) {\n  exports.createCanvas = createCanvasMethod;\n  exports.createCanvasFromData = createCanvasFromDataMethod || exports.createCanvasFromData;\n}\n\nexports.initializeCanvas = initializeCanvas;","map":null,"metadata":{},"sourceType":"script"}