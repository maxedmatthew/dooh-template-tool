{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar psd_1 = require(\"./psd\");\n\nvar helpers_1 = require(\"./helpers\");\n\nvar additionalInfo_1 = require(\"./additionalInfo\");\n\nvar imageResources_1 = require(\"./imageResources\");\n\nfunction createWriter(size) {\n  if (size === void 0) {\n    size = 1024;\n  }\n\n  var buffer = new ArrayBuffer(size);\n  var view = new DataView(buffer);\n  var offset = 0;\n  return {\n    buffer: buffer,\n    view: view,\n    offset: offset\n  };\n}\n\nexports.createWriter = createWriter;\n\nfunction getWriterBuffer(writer) {\n  return writer.buffer.slice(0, writer.offset);\n}\n\nexports.getWriterBuffer = getWriterBuffer;\n\nfunction writeUint8(writer, value) {\n  var offset = addSize(writer, 1);\n  writer.view.setUint8(offset, value);\n}\n\nexports.writeUint8 = writeUint8;\n\nfunction writeInt16(writer, value) {\n  var offset = addSize(writer, 2);\n  writer.view.setInt16(offset, value, false);\n}\n\nexports.writeInt16 = writeInt16;\n\nfunction writeUint16(writer, value) {\n  var offset = addSize(writer, 2);\n  writer.view.setUint16(offset, value, false);\n}\n\nexports.writeUint16 = writeUint16;\n\nfunction writeInt32(writer, value) {\n  var offset = addSize(writer, 4);\n  writer.view.setInt32(offset, value, false);\n}\n\nexports.writeInt32 = writeInt32;\n\nfunction writeUint32(writer, value) {\n  var offset = addSize(writer, 4);\n  writer.view.setUint32(offset, value, false);\n}\n\nexports.writeUint32 = writeUint32;\n\nfunction writeInt32At(writer, value, offset) {\n  writer.view.setInt32(offset, value, false);\n}\n\nexports.writeInt32At = writeInt32At;\n\nfunction writeFloat32(writer, value) {\n  var offset = addSize(writer, 4);\n  writer.view.setFloat32(offset, value, false);\n}\n\nexports.writeFloat32 = writeFloat32;\n\nfunction writeFloat64(writer, value) {\n  var offset = addSize(writer, 8);\n  writer.view.setFloat64(offset, value, false);\n}\n\nexports.writeFloat64 = writeFloat64;\n\nfunction writeBytes(writer, buffer) {\n  if (buffer) {\n    ensureSize(writer, writer.offset + buffer.length);\n    var bytes = new Uint8Array(writer.buffer);\n    bytes.set(buffer, writer.offset);\n    writer.offset += buffer.length;\n  }\n}\n\nexports.writeBytes = writeBytes;\n\nfunction writeZeros(writer, count) {\n  for (var i = 0; i < count; i++) {\n    writeUint8(writer, 0);\n  }\n}\n\nexports.writeZeros = writeZeros;\n\nfunction writeSignature(writer, signature) {\n  if (signature.length !== 4) {\n    throw new Error(\"Invalid signature: '\" + signature + \"'\");\n  }\n\n  for (var i = 0; i < 4; i++) {\n    writeUint8(writer, signature.charCodeAt(i));\n  }\n}\n\nexports.writeSignature = writeSignature; // export function writeUtf8String(writer: PsdWriter, value: string) {\n// \tconst buffer = encodeString(value);\n// \twriteBytes(writer, buffer);\n// }\n\nfunction writePascalString(writer, text, padTo) {\n  if (padTo === void 0) {\n    padTo = 2;\n  }\n\n  var length = text.length;\n  writeUint8(writer, length);\n\n  for (var i = 0; i < length; i++) {\n    var code = text.charCodeAt(i);\n    writeUint8(writer, code < 128 ? code : '?'.charCodeAt(0));\n  }\n\n  while (++length % padTo) {\n    writeUint8(writer, 0);\n  }\n}\n\nexports.writePascalString = writePascalString;\n\nfunction writeUnicodeString(writer, text) {\n  writeUint32(writer, text.length);\n\n  for (var i = 0; i < text.length; i++) {\n    writeUint16(writer, text.charCodeAt(i));\n  }\n}\n\nexports.writeUnicodeString = writeUnicodeString;\n\nfunction writeUnicodeStringWithPadding(writer, text) {\n  writeUint32(writer, text.length + 1);\n\n  for (var i = 0; i < text.length; i++) {\n    writeUint16(writer, text.charCodeAt(i));\n  }\n\n  writeUint16(writer, 0);\n}\n\nexports.writeUnicodeStringWithPadding = writeUnicodeStringWithPadding;\n\nfunction writeBuffer(writer, buffer) {\n  if (buffer) {\n    writeBytes(writer, buffer);\n  }\n}\n\nexports.writeBuffer = writeBuffer;\n\nfunction getLayerSize(layer) {\n  if (layer.canvas) {\n    var _a = helpers_1.getLayerDimentions(layer),\n        width = _a.width,\n        height = _a.height;\n\n    return 2 * height + 2 * width * height;\n  } else {\n    return 0;\n  }\n}\n\nfunction getLargestLayerSize(layers) {\n  if (layers === void 0) {\n    layers = [];\n  }\n\n  return layers.reduce(function (max, layer) {\n    return Math.max(max, getLayerSize(layer), getLargestLayerSize(layer.children));\n  }, 0);\n}\n\nfunction writeSection(writer, round, func) {\n  var offset = writer.offset;\n  writeInt32(writer, 0);\n  func();\n  var length = writer.offset - offset - 4;\n\n  while (length % round !== 0) {\n    writeUint8(writer, 0);\n    length++;\n  }\n\n  writeInt32At(writer, length, offset);\n}\n\nfunction writePsd(writer, psd, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  if (!(+psd.width > 0 && +psd.height > 0)) throw new Error('Invalid document size');\n  var imageResources = psd.imageResources || {};\n\n  if (options.generateThumbnail) {\n    imageResources = __assign({}, imageResources, {\n      thumbnail: createThumbnail(psd)\n    });\n  }\n\n  var canvas = psd.canvas;\n\n  if (canvas && (psd.width !== canvas.width || psd.height !== canvas.height)) {\n    throw new Error('Document canvas must have the same size as document');\n  }\n\n  var imageData = canvas && canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);\n  var globalAlpha = !!imageData && helpers_1.hasAlpha(imageData);\n  var maxBufferSize = Math.max(getLargestLayerSize(psd.children), 4 * 2 * psd.width * psd.height + 2 * psd.height);\n  var tempBuffer = new Uint8Array(maxBufferSize);\n  writeHeader(writer, psd, globalAlpha);\n  writeColorModeData(writer, psd);\n  writeImageResources(writer, imageResources);\n  writeLayerAndMaskInfo(tempBuffer, writer, psd, globalAlpha, options);\n  writeImageData(tempBuffer, writer, globalAlpha, psd.width, psd.height, imageData);\n}\n\nexports.writePsd = writePsd;\n\nfunction writeHeader(writer, psd, globalAlpha) {\n  writeSignature(writer, '8BPS');\n  writeUint16(writer, 1); // version\n\n  writeZeros(writer, 6);\n  writeUint16(writer, globalAlpha ? 4 : 3); // channels\n\n  writeUint32(writer, psd.height);\n  writeUint32(writer, psd.width);\n  writeUint16(writer, 8); // bits per channel\n\n  writeUint16(writer, 3\n  /* RGB */\n  );\n}\n\nfunction writeColorModeData(writer, _psd) {\n  writeSection(writer, 1, function () {// TODO: implement\n  });\n}\n\nfunction writeImageResources(writer, imageResources) {\n  writeSection(writer, 1, function () {\n    var _loop_1 = function _loop_1(handler) {\n      if (handler.has(imageResources)) {\n        writeSignature(writer, '8BIM');\n        writeUint16(writer, handler.key);\n        writePascalString(writer, '');\n        writeSection(writer, 2, function () {\n          return handler.write(writer, imageResources);\n        });\n      }\n    };\n\n    for (var _i = 0, _a = imageResources_1.getHandlers(); _i < _a.length; _i++) {\n      var handler = _a[_i];\n\n      _loop_1(handler);\n    }\n  });\n}\n\nfunction writeLayerAndMaskInfo(tempBuffer, writer, psd, globalAlpha, options) {\n  writeSection(writer, 2, function () {\n    writeLayerInfo(tempBuffer, writer, psd, globalAlpha, options);\n    writeGlobalLayerMaskInfo(writer);\n    writeAdditionalLayerInfo(writer, psd);\n  });\n}\n\nfunction writeLayerInfo(tempBuffer, writer, psd, globalAlpha, options) {\n  writeSection(writer, 2, function () {\n    var layers = [];\n    addChildren(layers, psd.children);\n\n    if (!layers.length) {\n      layers.push({});\n    }\n\n    writeInt16(writer, globalAlpha ? -layers.length : layers.length);\n    var layerData = layers.map(function (l, i) {\n      return helpers_1.getChannels(tempBuffer, l, i === 0, options);\n    });\n    layerData.forEach(function (l) {\n      return writeLayerRecord(writer, psd, l);\n    });\n    layerData.forEach(function (l) {\n      return writeLayerChannelImageData(writer, l);\n    });\n  });\n}\n\nvar LayerFlags;\n\n(function (LayerFlags) {\n  LayerFlags[LayerFlags[\"TransparencyProtected\"] = 1] = \"TransparencyProtected\";\n  LayerFlags[LayerFlags[\"Hidden\"] = 2] = \"Hidden\";\n  LayerFlags[LayerFlags[\"Obsolete\"] = 4] = \"Obsolete\";\n  LayerFlags[LayerFlags[\"HasRelevantBit4\"] = 8] = \"HasRelevantBit4\";\n  LayerFlags[LayerFlags[\"PixelDataIrrelevantToAppearanceOfDocument\"] = 16] = \"PixelDataIrrelevantToAppearanceOfDocument\";\n})(LayerFlags || (LayerFlags = {}));\n\nfunction writeLayerRecord(writer, psd, layerData) {\n  var layer = layerData.layer,\n      top = layerData.top,\n      left = layerData.left,\n      bottom = layerData.bottom,\n      right = layerData.right,\n      channels = layerData.channels;\n  writeInt32(writer, top);\n  writeInt32(writer, left);\n  writeInt32(writer, bottom);\n  writeInt32(writer, right);\n  writeUint16(writer, channels.length);\n\n  for (var _i = 0, channels_1 = channels; _i < channels_1.length; _i++) {\n    var c = channels_1[_i];\n    writeInt16(writer, c.channelId);\n    writeInt32(writer, c.length);\n  }\n\n  writeSignature(writer, '8BIM');\n  writeSignature(writer, psd_1.fromBlendMode[layer.blendMode || 'normal']);\n  writeUint8(writer, typeof layer.opacity !== 'undefined' ? layer.opacity : 255);\n  writeUint8(writer, layer.clipping ? 1 : 0);\n  var flags = 0 | (layer.transparencyProtected ? 1\n  /* TransparencyProtected */\n  : 0) | (layer.hidden ? 2\n  /* Hidden */\n  : 0) | 8\n  /* HasRelevantBit4 */\n  ;\n  writeUint8(writer, flags);\n  writeUint8(writer, 0); // filler\n\n  writeSection(writer, 1, function () {\n    writeLayerMaskData(writer, layer, layerData);\n    writeLayerBlendingRanges(writer, psd);\n    writePascalString(writer, layer.name || '', 4);\n    writeAdditionalLayerInfo(writer, layer);\n  });\n}\n\nfunction writeLayerMaskData(writer, _a, layerData) {\n  var mask = _a.mask;\n  writeSection(writer, 4, function () {\n    if (mask && layerData.mask) {\n      writeInt32(writer, layerData.mask.top);\n      writeInt32(writer, layerData.mask.left);\n      writeInt32(writer, layerData.mask.bottom);\n      writeInt32(writer, layerData.mask.right);\n      writeUint8(writer, mask.defaultColor || 0);\n      var flags = 0 | (mask.disabled ? 2\n      /* LayerMaskDisabled */\n      : 0) | (mask.positionRelativeToLayer ? 1\n      /* PositionRelativeToLayer */\n      : 0);\n      writeUint8(writer, flags);\n      var parameters = 0 | (mask.userMaskDensity !== undefined ? 1\n      /* UserMaskDensity */\n      : 0) | (mask.userMaskFeather !== undefined ? 2\n      /* UserMaskFeather */\n      : 0) | (mask.vectorMaskDensity !== undefined ? 1\n      /* UserMaskDensity */\n      : 0) | (mask.vectorMaskFeather !== undefined ? 2\n      /* UserMaskFeather */\n      : 0);\n\n      if (parameters) {\n        writeUint8(writer, parameters);\n        if (mask.userMaskDensity !== undefined) writeUint8(writer, mask.userMaskDensity);\n        if (mask.userMaskFeather !== undefined) writeFloat64(writer, mask.userMaskFeather);\n        if (mask.vectorMaskDensity !== undefined) writeUint8(writer, mask.vectorMaskDensity);\n        if (mask.vectorMaskFeather !== undefined) writeFloat64(writer, mask.vectorMaskFeather);\n      } // TODO: handler rest of the fields\n      // writeZeros(writer, 2);\n\n    }\n  });\n}\n\nfunction writeLayerBlendingRanges(writer, psd) {\n  writeSection(writer, 1, function () {\n    writeUint32(writer, 65535);\n    writeUint32(writer, 65535); // TODO: use always 4 instead ?\n\n    var channels = psd.channels || 0;\n\n    for (var i = 0; i < channels; i++) {\n      writeUint32(writer, 65535);\n      writeUint32(writer, 65535);\n    }\n  });\n}\n\nfunction writeLayerChannelImageData(writer, _a) {\n  var channels = _a.channels;\n\n  for (var _i = 0, channels_2 = channels; _i < channels_2.length; _i++) {\n    var channel = channels_2[_i];\n    writeUint16(writer, channel.compression);\n\n    if (channel.buffer) {\n      writeBuffer(writer, channel.buffer);\n    }\n  }\n}\n\nfunction writeGlobalLayerMaskInfo(writer) {\n  writeSection(writer, 1, function () {// TODO: implement\n  });\n}\n\nfunction writeAdditionalLayerInfo(writer, target) {\n  var _loop_2 = function _loop_2(handler) {\n    if (handler.has(target)) {\n      writeSignature(writer, '8BIM');\n      writeSignature(writer, handler.key);\n      writeSection(writer, 4, function () {\n        return handler.write(writer, target);\n      });\n    }\n  };\n\n  for (var _i = 0, _a = additionalInfo_1.getHandlers(); _i < _a.length; _i++) {\n    var handler = _a[_i];\n\n    _loop_2(handler);\n  }\n}\n\nfunction writeImageData(tempBuffer, writer, globalAlpha, width, height, imageData) {\n  var channels = globalAlpha ? [0, 1, 2, 3] : [0, 1, 2];\n  var data = imageData || {\n    data: new Uint8Array(4 * width * height),\n    width: width,\n    height: height\n  };\n  writeUint16(writer, 1\n  /* RleCompressed */\n  );\n  writeBytes(writer, helpers_1.writeDataRLE(tempBuffer, data, width, height, channels));\n}\n\nfunction addChildren(layers, children) {\n  if (!children) return;\n\n  for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {\n    var c = children_1[_i];\n\n    if (c.children && c.canvas) {\n      throw new Error(\"Invalid layer: cannot have both 'canvas' and 'children' properties set\");\n    }\n\n    if (c.children) {\n      var sectionDivider = {\n        type: c.opened === false ? 2\n        /* ClosedFolder */\n        : 1\n        /* OpenFolder */\n        ,\n        key: 'pass',\n        subtype: 0\n      };\n      layers.push({\n        name: '</Layer group>',\n        sectionDivider: {\n          type: 3\n          /* BoundingSectionDivider */\n\n        }\n      });\n      addChildren(layers, c.children);\n      layers.push(__assign({}, c, {\n        sectionDivider: sectionDivider\n      }));\n    } else {\n      layers.push(__assign({}, c));\n    }\n  }\n}\n\nfunction resizeBuffer(writer, size) {\n  var newLength = writer.buffer.byteLength;\n\n  do {\n    newLength *= 2;\n  } while (size > newLength);\n\n  var newBuffer = new ArrayBuffer(newLength);\n  var newBytes = new Uint8Array(newBuffer);\n  var oldBytes = new Uint8Array(writer.buffer);\n  newBytes.set(oldBytes);\n  writer.buffer = newBuffer;\n  writer.view = new DataView(writer.buffer);\n}\n\nfunction ensureSize(writer, size) {\n  if (size > writer.buffer.byteLength) {\n    resizeBuffer(writer, size);\n  }\n}\n\nfunction addSize(writer, size) {\n  var offset = writer.offset;\n  ensureSize(writer, writer.offset += size);\n  return offset;\n}\n\nfunction createThumbnail(psd) {\n  var canvas = helpers_1.createCanvas(10, 10);\n  var scale = 1;\n\n  if (psd.width > psd.height) {\n    canvas.width = 160;\n    canvas.height = Math.floor(psd.height * (canvas.width / psd.width));\n    scale = canvas.width / psd.width;\n  } else {\n    canvas.height = 160;\n    canvas.width = Math.floor(psd.width * (canvas.height / psd.height));\n    scale = canvas.height / psd.height;\n  }\n\n  var context = canvas.getContext('2d');\n  context.scale(scale, scale);\n\n  if (psd.canvas) {\n    context.drawImage(psd.canvas, 0, 0);\n  }\n\n  return canvas;\n}","map":null,"metadata":{},"sourceType":"script"}